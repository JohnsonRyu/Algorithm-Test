# Read Numbers
숫자 배열을 받아서 연속된 숫자를 문자열로 바꾸세요.

```
readNumbers([1]) // "1"
readNumbers([1, 3]) // "1, 3"
readNumbers([1, 2, 3]) // "1~3"
readNumbers([1, 2, 3, 6, 8, 9, 10]) // "1~3, 6, 8~10"
readNumbers([13, 14, 15, 16, 20, 23, 24, 25, 100]) // "13~16, 20, 23~25, 100"
```

### 생각의 흐름
(1) 반복문을 돌려서 연속되는 수를 찾아낸다. 이후 음수에 대한 처리를 진행하고 유효하지 않은 값에 대한 예외처리도 고려한다.<br>
(2) ~~배열에 push 하는 것은 n+1번째에서 처리해야한다. 이에따라 마지막 index의 경우 예외처리가 필요하다.~~<br>
(3) n+1에서 처리하면, 조건문이 너무 많아짐. n 번째에서 즉시 처리할 수 있어야한다.<br>
(4) 바로 비교하고 연속된 수를 string으로 만들면 n+2번째 비교는 이미 string으로 변해버린 n,n+1 중 n+1을 구하기 위하여 split 해야한다. 이 방법은 비효율적이기 때문에 바로 string으로 연결 하지말고 `combo`라는 변수로 연속된 수를 체크해야한다.<br>


# 피드백
(velopert님) Return Early: http://wilsonpage.co.uk/return-early/ if-else를 여러 번 사용하지 않고 필요할 때에는 일찍 return을 하여 if 문이 여러 번 중첩되는 것을 방지할 수 있습니다. 물론 이 방식을 무조건 사용해야 하는 것은 아니지만, 어떤 방법이던 가능하면 if문이 복잡해지는 것을 최대한 피하는 것이 코드의 가독성에 좋습니다.

재귀 함수 또는 배열의 내장 함수 활용 재귀 함수를 사용하시거나, 또는 배열의 내장 함수 (map과 reduce)를 활용하면 더 깔끔한 코드로 구현할 수 있습니다.

### 실행

```
$ yarn install
```

```
$ yarn start
```